// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'terms_of_use_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TermsOfUseEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadTermsOfUseVersion,
    required TResult Function(AppMetadata appMetadata) appMetadataUpdated,
    required TResult Function() acceptTerms,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadTermsOfUseVersion,
    TResult? Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult? Function()? acceptTerms,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadTermsOfUseVersion,
    TResult Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult Function()? acceptTerms,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TermsOfUseLoadTermsOfUseVersion value)
        loadTermsOfUseVersion,
    required TResult Function(TermsOfUseAppMetadataUpdated value)
        appMetadataUpdated,
    required TResult Function(TermsOfUseAcceptTerms value) acceptTerms,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult? Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult? Function(TermsOfUseAcceptTerms value)? acceptTerms,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult Function(TermsOfUseAcceptTerms value)? acceptTerms,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TermsOfUseEventCopyWith<$Res> {
  factory $TermsOfUseEventCopyWith(
          TermsOfUseEvent value, $Res Function(TermsOfUseEvent) then) =
      _$TermsOfUseEventCopyWithImpl<$Res, TermsOfUseEvent>;
}

/// @nodoc
class _$TermsOfUseEventCopyWithImpl<$Res, $Val extends TermsOfUseEvent>
    implements $TermsOfUseEventCopyWith<$Res> {
  _$TermsOfUseEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TermsOfUseLoadTermsOfUseVersionImplCopyWith<$Res> {
  factory _$$TermsOfUseLoadTermsOfUseVersionImplCopyWith(
          _$TermsOfUseLoadTermsOfUseVersionImpl value,
          $Res Function(_$TermsOfUseLoadTermsOfUseVersionImpl) then) =
      __$$TermsOfUseLoadTermsOfUseVersionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TermsOfUseLoadTermsOfUseVersionImplCopyWithImpl<$Res>
    extends _$TermsOfUseEventCopyWithImpl<$Res,
        _$TermsOfUseLoadTermsOfUseVersionImpl>
    implements _$$TermsOfUseLoadTermsOfUseVersionImplCopyWith<$Res> {
  __$$TermsOfUseLoadTermsOfUseVersionImplCopyWithImpl(
      _$TermsOfUseLoadTermsOfUseVersionImpl _value,
      $Res Function(_$TermsOfUseLoadTermsOfUseVersionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TermsOfUseLoadTermsOfUseVersionImpl
    implements TermsOfUseLoadTermsOfUseVersion {
  const _$TermsOfUseLoadTermsOfUseVersionImpl();

  @override
  String toString() {
    return 'TermsOfUseEvent.loadTermsOfUseVersion()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TermsOfUseLoadTermsOfUseVersionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadTermsOfUseVersion,
    required TResult Function(AppMetadata appMetadata) appMetadataUpdated,
    required TResult Function() acceptTerms,
  }) {
    return loadTermsOfUseVersion();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadTermsOfUseVersion,
    TResult? Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult? Function()? acceptTerms,
  }) {
    return loadTermsOfUseVersion?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadTermsOfUseVersion,
    TResult Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult Function()? acceptTerms,
    required TResult orElse(),
  }) {
    if (loadTermsOfUseVersion != null) {
      return loadTermsOfUseVersion();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TermsOfUseLoadTermsOfUseVersion value)
        loadTermsOfUseVersion,
    required TResult Function(TermsOfUseAppMetadataUpdated value)
        appMetadataUpdated,
    required TResult Function(TermsOfUseAcceptTerms value) acceptTerms,
  }) {
    return loadTermsOfUseVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult? Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult? Function(TermsOfUseAcceptTerms value)? acceptTerms,
  }) {
    return loadTermsOfUseVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult Function(TermsOfUseAcceptTerms value)? acceptTerms,
    required TResult orElse(),
  }) {
    if (loadTermsOfUseVersion != null) {
      return loadTermsOfUseVersion(this);
    }
    return orElse();
  }
}

abstract class TermsOfUseLoadTermsOfUseVersion implements TermsOfUseEvent {
  const factory TermsOfUseLoadTermsOfUseVersion() =
      _$TermsOfUseLoadTermsOfUseVersionImpl;
}

/// @nodoc
abstract class _$$TermsOfUseAppMetadataUpdatedImplCopyWith<$Res> {
  factory _$$TermsOfUseAppMetadataUpdatedImplCopyWith(
          _$TermsOfUseAppMetadataUpdatedImpl value,
          $Res Function(_$TermsOfUseAppMetadataUpdatedImpl) then) =
      __$$TermsOfUseAppMetadataUpdatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AppMetadata appMetadata});

  $AppMetadataCopyWith<$Res> get appMetadata;
}

/// @nodoc
class __$$TermsOfUseAppMetadataUpdatedImplCopyWithImpl<$Res>
    extends _$TermsOfUseEventCopyWithImpl<$Res,
        _$TermsOfUseAppMetadataUpdatedImpl>
    implements _$$TermsOfUseAppMetadataUpdatedImplCopyWith<$Res> {
  __$$TermsOfUseAppMetadataUpdatedImplCopyWithImpl(
      _$TermsOfUseAppMetadataUpdatedImpl _value,
      $Res Function(_$TermsOfUseAppMetadataUpdatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appMetadata = null,
  }) {
    return _then(_$TermsOfUseAppMetadataUpdatedImpl(
      appMetadata: null == appMetadata
          ? _value.appMetadata
          : appMetadata // ignore: cast_nullable_to_non_nullable
              as AppMetadata,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppMetadataCopyWith<$Res> get appMetadata {
    return $AppMetadataCopyWith<$Res>(_value.appMetadata, (value) {
      return _then(_value.copyWith(appMetadata: value));
    });
  }
}

/// @nodoc

class _$TermsOfUseAppMetadataUpdatedImpl
    implements TermsOfUseAppMetadataUpdated {
  const _$TermsOfUseAppMetadataUpdatedImpl({required this.appMetadata});

  @override
  final AppMetadata appMetadata;

  @override
  String toString() {
    return 'TermsOfUseEvent.appMetadataUpdated(appMetadata: $appMetadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TermsOfUseAppMetadataUpdatedImpl &&
            (identical(other.appMetadata, appMetadata) ||
                other.appMetadata == appMetadata));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appMetadata);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TermsOfUseAppMetadataUpdatedImplCopyWith<
          _$TermsOfUseAppMetadataUpdatedImpl>
      get copyWith => __$$TermsOfUseAppMetadataUpdatedImplCopyWithImpl<
          _$TermsOfUseAppMetadataUpdatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadTermsOfUseVersion,
    required TResult Function(AppMetadata appMetadata) appMetadataUpdated,
    required TResult Function() acceptTerms,
  }) {
    return appMetadataUpdated(appMetadata);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadTermsOfUseVersion,
    TResult? Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult? Function()? acceptTerms,
  }) {
    return appMetadataUpdated?.call(appMetadata);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadTermsOfUseVersion,
    TResult Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult Function()? acceptTerms,
    required TResult orElse(),
  }) {
    if (appMetadataUpdated != null) {
      return appMetadataUpdated(appMetadata);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TermsOfUseLoadTermsOfUseVersion value)
        loadTermsOfUseVersion,
    required TResult Function(TermsOfUseAppMetadataUpdated value)
        appMetadataUpdated,
    required TResult Function(TermsOfUseAcceptTerms value) acceptTerms,
  }) {
    return appMetadataUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult? Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult? Function(TermsOfUseAcceptTerms value)? acceptTerms,
  }) {
    return appMetadataUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult Function(TermsOfUseAcceptTerms value)? acceptTerms,
    required TResult orElse(),
  }) {
    if (appMetadataUpdated != null) {
      return appMetadataUpdated(this);
    }
    return orElse();
  }
}

abstract class TermsOfUseAppMetadataUpdated implements TermsOfUseEvent {
  const factory TermsOfUseAppMetadataUpdated(
          {required final AppMetadata appMetadata}) =
      _$TermsOfUseAppMetadataUpdatedImpl;

  AppMetadata get appMetadata;
  @JsonKey(ignore: true)
  _$$TermsOfUseAppMetadataUpdatedImplCopyWith<
          _$TermsOfUseAppMetadataUpdatedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TermsOfUseAcceptTermsImplCopyWith<$Res> {
  factory _$$TermsOfUseAcceptTermsImplCopyWith(
          _$TermsOfUseAcceptTermsImpl value,
          $Res Function(_$TermsOfUseAcceptTermsImpl) then) =
      __$$TermsOfUseAcceptTermsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TermsOfUseAcceptTermsImplCopyWithImpl<$Res>
    extends _$TermsOfUseEventCopyWithImpl<$Res, _$TermsOfUseAcceptTermsImpl>
    implements _$$TermsOfUseAcceptTermsImplCopyWith<$Res> {
  __$$TermsOfUseAcceptTermsImplCopyWithImpl(_$TermsOfUseAcceptTermsImpl _value,
      $Res Function(_$TermsOfUseAcceptTermsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TermsOfUseAcceptTermsImpl implements TermsOfUseAcceptTerms {
  const _$TermsOfUseAcceptTermsImpl();

  @override
  String toString() {
    return 'TermsOfUseEvent.acceptTerms()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TermsOfUseAcceptTermsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadTermsOfUseVersion,
    required TResult Function(AppMetadata appMetadata) appMetadataUpdated,
    required TResult Function() acceptTerms,
  }) {
    return acceptTerms();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadTermsOfUseVersion,
    TResult? Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult? Function()? acceptTerms,
  }) {
    return acceptTerms?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadTermsOfUseVersion,
    TResult Function(AppMetadata appMetadata)? appMetadataUpdated,
    TResult Function()? acceptTerms,
    required TResult orElse(),
  }) {
    if (acceptTerms != null) {
      return acceptTerms();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TermsOfUseLoadTermsOfUseVersion value)
        loadTermsOfUseVersion,
    required TResult Function(TermsOfUseAppMetadataUpdated value)
        appMetadataUpdated,
    required TResult Function(TermsOfUseAcceptTerms value) acceptTerms,
  }) {
    return acceptTerms(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult? Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult? Function(TermsOfUseAcceptTerms value)? acceptTerms,
  }) {
    return acceptTerms?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TermsOfUseLoadTermsOfUseVersion value)?
        loadTermsOfUseVersion,
    TResult Function(TermsOfUseAppMetadataUpdated value)? appMetadataUpdated,
    TResult Function(TermsOfUseAcceptTerms value)? acceptTerms,
    required TResult orElse(),
  }) {
    if (acceptTerms != null) {
      return acceptTerms(this);
    }
    return orElse();
  }
}

abstract class TermsOfUseAcceptTerms implements TermsOfUseEvent {
  const factory TermsOfUseAcceptTerms() = _$TermsOfUseAcceptTermsImpl;
}

/// @nodoc
mixin _$TermsOfUseState {
  bool get isLoading => throw _privateConstructorUsedError;
  AppMetadata? get appMetadata => throw _privateConstructorUsedError;
  Failure? get failure => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TermsOfUseStateCopyWith<TermsOfUseState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TermsOfUseStateCopyWith<$Res> {
  factory $TermsOfUseStateCopyWith(
          TermsOfUseState value, $Res Function(TermsOfUseState) then) =
      _$TermsOfUseStateCopyWithImpl<$Res, TermsOfUseState>;
  @useResult
  $Res call({bool isLoading, AppMetadata? appMetadata, Failure? failure});

  $AppMetadataCopyWith<$Res>? get appMetadata;
}

/// @nodoc
class _$TermsOfUseStateCopyWithImpl<$Res, $Val extends TermsOfUseState>
    implements $TermsOfUseStateCopyWith<$Res> {
  _$TermsOfUseStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? appMetadata = freezed,
    Object? failure = freezed,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      appMetadata: freezed == appMetadata
          ? _value.appMetadata
          : appMetadata // ignore: cast_nullable_to_non_nullable
              as AppMetadata?,
      failure: freezed == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppMetadataCopyWith<$Res>? get appMetadata {
    if (_value.appMetadata == null) {
      return null;
    }

    return $AppMetadataCopyWith<$Res>(_value.appMetadata!, (value) {
      return _then(_value.copyWith(appMetadata: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TermsOfUseStateImplCopyWith<$Res>
    implements $TermsOfUseStateCopyWith<$Res> {
  factory _$$TermsOfUseStateImplCopyWith(_$TermsOfUseStateImpl value,
          $Res Function(_$TermsOfUseStateImpl) then) =
      __$$TermsOfUseStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isLoading, AppMetadata? appMetadata, Failure? failure});

  @override
  $AppMetadataCopyWith<$Res>? get appMetadata;
}

/// @nodoc
class __$$TermsOfUseStateImplCopyWithImpl<$Res>
    extends _$TermsOfUseStateCopyWithImpl<$Res, _$TermsOfUseStateImpl>
    implements _$$TermsOfUseStateImplCopyWith<$Res> {
  __$$TermsOfUseStateImplCopyWithImpl(
      _$TermsOfUseStateImpl _value, $Res Function(_$TermsOfUseStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? appMetadata = freezed,
    Object? failure = freezed,
  }) {
    return _then(_$TermsOfUseStateImpl(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      appMetadata: freezed == appMetadata
          ? _value.appMetadata
          : appMetadata // ignore: cast_nullable_to_non_nullable
              as AppMetadata?,
      failure: freezed == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure?,
    ));
  }
}

/// @nodoc

class _$TermsOfUseStateImpl implements _TermsOfUseState {
  const _$TermsOfUseStateImpl(
      {this.isLoading = false, this.appMetadata, this.failure});

  @override
  @JsonKey()
  final bool isLoading;
  @override
  final AppMetadata? appMetadata;
  @override
  final Failure? failure;

  @override
  String toString() {
    return 'TermsOfUseState(isLoading: $isLoading, appMetadata: $appMetadata, failure: $failure)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TermsOfUseStateImpl &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.appMetadata, appMetadata) ||
                other.appMetadata == appMetadata) &&
            (identical(other.failure, failure) || other.failure == failure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isLoading, appMetadata, failure);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TermsOfUseStateImplCopyWith<_$TermsOfUseStateImpl> get copyWith =>
      __$$TermsOfUseStateImplCopyWithImpl<_$TermsOfUseStateImpl>(
          this, _$identity);
}

abstract class _TermsOfUseState implements TermsOfUseState {
  const factory _TermsOfUseState(
      {final bool isLoading,
      final AppMetadata? appMetadata,
      final Failure? failure}) = _$TermsOfUseStateImpl;

  @override
  bool get isLoading;
  @override
  AppMetadata? get appMetadata;
  @override
  Failure? get failure;
  @override
  @JsonKey(ignore: true)
  _$$TermsOfUseStateImplCopyWith<_$TermsOfUseStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
